<?xml version="1.0"?>

<!--This Document Type Definition (DTD) describes the layout of the RapidControl for
	CLI project file.  This project was originally generated by the GUI-based 
	RapidControl Integration Tool (RCIT), and can be used by either the RCIT or 
	by any console tool that requires a RapidControl for CLI project file.
	
	Please refer to the comment in the corresponding base RapidControl project for
	more information on the DTD below and on how to modify this file.
-->

<!DOCTYPE rcc_project [
	<!ELEMENT rcc_project ( general, options_h, custom_param_list, command_node_list)>
		<!ATTLIST rcc_project version_major CDATA #REQUIRED>
		<!ATTLIST rcc_project version_minor CDATA #REQUIRED>

	<!ELEMENT general (cli_h_preamble, cli_c_preamble, hnd_preamble, custom_flag_list)>
		<!ATTLIST general output_directory CDATA #REQUIRED>
		<!ATTLIST general handlers_source CDATA #REQUIRED>
		<!ATTLIST general access_options CDATA #REQUIRED>
	<!ELEMENT cli_h_preamble (#PCDATA)>
		<!ATTLIST cli_h_preamble xml:space (default | preserve) "preserve">
	<!ELEMENT cli_c_preamble (#PCDATA)>
		<!ATTLIST cli_c_preamble xml:space (default | preserve) "preserve">
	<!ELEMENT hnd_preamble (#PCDATA)>
		<!ATTLIST hnd_preamble xml:space (default | preserve) "preserve">

	<!ELEMENT custom_flag_list ( cfl* )>
	<!ELEMENT cfl EMPTY>
		<!ATTLIST cfl name CDATA #REQUIRED>
		<!ATTLIST cfl flag CDATA #REQUIRED>

	<!ELEMENT options_h (telnet, login, shell, command, system)>

	<!ELEMENT telnet EMPTY>
		<!ATTLIST telnet port CDATA #REQUIRED>
		<!ATTLIST telnet thread_stack_size CDATA #REQUIRED>
		<!ATTLIST telnet server_priority CDATA #REQUIRED>
		<!ATTLIST telnet timeout CDATA #REQUIRED>

	<!ELEMENT login EMPTY>
		<!ATTLIST login maximum CDATA #REQUIRED>
		<!ATTLIST login length CDATA #REQUIRED>
		<!ATTLIST login password_length CDATA #REQUIRED>
		<!ATTLIST login prompt CDATA #REQUIRED>
		<!ATTLIST login password_prompt CDATA #REQUIRED>

	<!ELEMENT shell EMPTY>
		<!ATTLIST shell number_history CDATA #REQUIRED>
		<!ATTLIST shell default_prompt CDATA #REQUIRED>
		<!ATTLIST shell maximum_token CDATA #REQUIRED>
		<!ATTLIST shell alias_buf_size CDATA #REQUIRED>
		<!ATTLIST shell alias_count CDATA #REQUIRED>

	<!ELEMENT command EMPTY>
		<!ATTLIST command prompt_length CDATA #REQUIRED>
		<!ATTLIST command length CDATA #REQUIRED>
		<!ATTLIST command maximum_parameter CDATA #REQUIRED>
		<!ATTLIST command output_buffer_size CDATA #REQUIRED>
		<!ATTLIST command enable_console ( true | false ) #REQUIRED>

	<!ELEMENT system EMPTY>
		<!ATTLIST system maximum_task CDATA #REQUIRED>
		<!ATTLIST system param_order (None | Unnamed | Full) #REQUIRED>

	<!ELEMENT custom_param_list (cp*)>
	<!ELEMENT cp (#PCDATA)>
		<!ATTLIST cp typename CDATA #REQUIRED>
		<!ATTLIST cp typebase (null		|
						 char		| unsigned_char		|
						 short		| unsigned_short	|
						 integer	| unsigned_integer	|
						 long   	| unsigned_long 	|
						 ip_address	| mac_address		|
						 enumerate  | list				|
						 string		| absolute ) #REQUIRED>
		<!ATTLIST cp validstr CDATA #REQUIRED>
		<!ATTLIST cp accessstr CDATA #REQUIRED>
		<!ATTLIST cp defaultstr CDATA #REQUIRED>
		<!ATTLIST cp customvalid CDATA #REQUIRED>
		<!ATTLIST cp convert2base CDATA #REQUIRED>
		<!ATTLIST cp helpmethod (0 | 1) #REQUIRED>
		<!ATTLIST cp helpstr CDATA #REQUIRED>
		<!ATTLIST cp helphandler CDATA #REQUIRED>

	<!ELEMENT parameter_list ( pd* )>
	<!ELEMENT pd (#PCDATA)>
		<!ATTLIST pd keyword CDATA #REQUIRED>
		<!ATTLIST pd type (null		|
						 char		| unsigned_char		|
						 short		| unsigned_short	|
						 integer	| unsigned_integer	|
						 long   	| unsigned_long 	|
						 ip_address	| mac_address		|
						 enumerate  | list				|
						 string		| absolute ) #REQUIRED>
		<!ATTLIST pd set_rapidmark CDATA #REQUIRED>
		<!ATTLIST pd paramnum CDATA #REQUIRED>
		<!ATTLIST pd nokeyword CDATA #REQUIRED>
		<!ATTLIST pd typename CDATA #REQUIRED>
		<!ATTLIST pd validstr CDATA #REQUIRED>
		<!ATTLIST pd accessstr CDATA #REQUIRED>
		<!ATTLIST pd defaultstr CDATA #REQUIRED>
		<!ATTLIST pd customvalid CDATA #REQUIRED>
		<!ATTLIST pd helpmethod (0 | 1) #REQUIRED>
		<!ATTLIST pd helpstr CDATA #REQUIRED>
		<!ATTLIST pd helphandler CDATA #REQUIRED>
		<!ATTLIST pd convert2base CDATA #REQUIRED>

	<!ELEMENT handler_param_order ( ho* )>
	<!ELEMENT ho EMPTY>
		<!ATTLIST ho paramnam CDATA #REQUIRED>
		<!ATTLIST ho paramnum CDATA #REQUIRED>
		<!ATTLIST ho type (required | optional) #REQUIRED>

	<!ELEMENT handler_list ( hd* )>
	<!ELEMENT hd (#PCDATA | handler_param_order)*>
		<!ATTLIST hd req_param_mask CDATA #REQUIRED>
		<!ATTLIST hd opt_param_mask CDATA #REQUIRED>
		<!ATTLIST hd type CDATA #REQUIRED>
		<!ATTLIST hd func CDATA #REQUIRED>
		<!ATTLIST hd xml:space (default | preserve) "preserve">

	<!ELEMENT command_node_list ( command_node* )>
	<!ELEMENT command_node ( parameter_list, handler_list, command_node_list, get_rapidmark_list, custflag_list )>
		<!ATTLIST command_node keyword CDATA #REQUIRED>
		<!ATTLIST command_node helpmethod (0 | 1) #REQUIRED>
		<!ATTLIST command_node help CDATA #REQUIRED>
		<!ATTLIST command_node helphandler CDATA #REQUIRED>
		<!ATTLIST command_node mode_support ( true | false ) #REQUIRED>
		<!ATTLIST command_node prompt_string CDATA #REQUIRED>
		<!ATTLIST command_node access_level CDATA #REQUIRED>
		<!ATTLIST command_node partition CDATA #REQUIRED>
		<!ATTLIST command_node allow_no_form ( true | false ) #REQUIRED>
		<!ATTLIST command_node inherit_rapidmarks ( true | false ) #REQUIRED>
		<!ATTLIST command_node global_node ( true | false ) #REQUIRED>
		<!ATTLIST command_node no_generate ( true | false ) #REQUIRED>
		<!ATTLIST command_node meta_node ( true | false ) #REQUIRED>
		<!ATTLIST command_node queue_node ( true | false ) #REQUIRED>
		<!ATTLIST command_node nolink_node ( true | false ) #REQUIRED>

	<!ELEMENT get_rapidmark_list ( rm* )>
	<!ELEMENT rm EMPTY>
		<!ATTLIST rm name CDATA #REQUIRED>

	<!ELEMENT custflag_list ( cf* )>
	<!ELEMENT cf EMPTY>
		<!ATTLIST cf flag CDATA #REQUIRED>
]>

<rcc_project
	version_major="3"
	version_minor="30">

	<general	output_directory="..\rc_gen\"	handlers_source="..\rc_gen\"	access_options="N=3 D=| T=ENABLE|CONFIG|SUPER|">
		<cli_h_preamble>
		</cli_h_preamble>

		<cli_c_preamble>
		</cli_c_preamble>

		<hnd_preamble>
#include &quot;mconfig.h&quot;
#include &quot;cli_sys.h&quot;		</hnd_preamble>

		<custom_flag_list>
			<cfl	name="Custom1"	flag="kRCC_COMMAND_CUSTOM1" />
			<cfl	name="Custom2"	flag="kRCC_COMMAND_CUSTOM2" />
			<cfl	name="Custom3"	flag="kRCC_COMMAND_CUSTOM3" />
		</custom_flag_list>

	</general>

	<options_h>
		<telnet
			port="23"
			thread_stack_size="512"
			server_priority="3"
			timeout="180" />

		<login
			maximum="3"
			length="16"
			password_length="16"
			prompt="Username:"
			password_prompt="Password:" />

		<shell
			number_history="10"
			default_prompt="OBSwitch"
			maximum_token="64"
			alias_buf_size="256"
			alias_count="16" />

		<command
			prompt_length="64"
			length="256"
			maximum_parameter="16"
			output_buffer_size="kMagicMarkupBufferSize"
			enable_console="true" />

		<system
			maximum_task="1"
			param_order="Full" />

	</options_h>

	<custom_param_list>
	</custom_param_list>

	<command_node_list>
		<command_node	keyword="clear"	helpmethod="0"	help="Enter clear commands level"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
			</handler_list>

			<command_node_list>
				<command_node	keyword="counters"	helpmethod="0"	help="Clear port MIB counters"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="port"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Logic port number"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_clear_counters">
extern RLSTATUS 
rcc_clear_counters(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_clear_counters_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="port"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="mac-address-table"	helpmethod="0"	help="Clear MAC address table"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_clear_mac_addr_table">
extern RLSTATUS 
rcc_clear_mac_addr_table(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
   status = cli_clear_mac_addr_table_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="config"	helpmethod="0"	help="Enter configuration command level"	helphandler=""	mode_support="true"	prompt_string="config"	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
			</handler_list>

			<command_node_list>
				<command_node	keyword="alarm"	helpmethod="0"	help="Alarm configuration"	helphandler=""	mode_support="true"	prompt_string="config-alarm"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="bootdelay"	helpmethod="0"	help="Config the bootdelay time(seconds)"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="seconds"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr="L=0 U=5"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Bootdelay time (should be 0-5)"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000001"	func="rcc_config_bootdelay">
extern RLSTATUS 
rcc_config_bootdelay(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
	
	status = cli_config_bootdelay_handler(pCliEnv, pParams, pAuxBuf);
    
	return status;
}							<handler_param_order>
								<ho	paramnam="seconds"	paramnum="0"	type="optional" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="ip"	helpmethod="0"	help="To configure ipaddress/netmask"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="ip"	type="ip_address"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="IP address"	helphandler="" />
						<pd	keyword="netmask"	type="ip_address"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Subnet mask"	helphandler="" />
						<pd	keyword="gateway"	type="ip_address"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Gateway IP"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000006"	func="rcc_config_ip">
extern RLSTATUS 
rcc_config_ip(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_ip_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="ip"	paramnum="0"	type="required" />
								<ho	paramnam="netmask"	paramnum="1"	type="optional" />
								<ho	paramnam="gateway"	paramnum="2"	type="optional" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="mirror"	helpmethod="0"	help="Port mirror configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="destination-port"	helpmethod="0"	help="Mirror destination port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="port"	type="unsigned_integer"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned integer"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mirror destination port number"	helphandler="" />
								<pd	keyword="direction"	type="enumerate"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=ingress|egress|ingress-egress|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mirror direction (ingress/egress/ingress-egress)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_config_mirror_destination_port">
extern RLSTATUS 
rcc_config_mirror_destination_port(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal1 = NULL;
    paramDescr  *pParamDescr1;
    sbyte       *pVal2 = NULL;
    paramDescr  *pParamDescr2;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;port&quot;, mConfigMirrorDestination_port_Port, &amp;pParamDescr1 );
    if ( OK != status )
    {
		return(status);
    } else pVal1 = (sbyte*)(pParamDescr1-&gt;pValue);

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;direction&quot;, mConfigMirrorDestination_port_Direction, &amp;pParamDescr2 );
    if ( OK != status )
    {
		return(status);
    } else pVal2 = (sbyte*)(pParamDescr2-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="port"	paramnum="0"	type="required" />
										<ho	paramnam="direction"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="source-port"	helpmethod="0"	help="Mirror source port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="portlist"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mirror source port list"	helphandler="" />
								<pd	keyword="direction"	type="enumerate"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=ingress|egress|ingress-egress|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mirror direction (ingress/egress/ingress-egress)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_config_mirror_source_port">
extern RLSTATUS 
rcc_config_mirror_source_port(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal1 = NULL;
    paramDescr  *pParamDescr1;
    sbyte       *pVal2 = NULL;
    paramDescr  *pParamDescr2;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;portlist&quot;, mConfigMirrorSource_port_Portlist, &amp;pParamDescr1 );
    if ( OK != status )
    {
		return(status);
    } else pVal1 = (sbyte*)(pParamDescr1-&gt;pValue);

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;direction&quot;, mConfigMirrorSource_port_Direction, &amp;pParamDescr2 );
    if ( OK != status )
    {
		return(status);
    } else pVal2 = (sbyte*)(pParamDescr2-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="portlist"	paramnum="0"	type="required" />
										<ho	paramnam="direction"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="obring"	helpmethod="0"	help="OB-Ring Protocol"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="delete"	helpmethod="0"	help="Delete OB-Ring domain"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="domain_id"	type="unsigned_short"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned short"	validstr="L=1 U=31"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Domain id, Range &lt;1-31&gt;"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_delete">
extern RLSTATUS 
rcc_config_obring_delete(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_delete_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="domain_id"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="domain_id"	helpmethod="0"	help="Enter specified domain configuration mode"	helphandler=""	mode_support="true"	prompt_string="config-domain-[[gDomainID]]"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="true"	partition="">
							<parameter_list>
								<pd	keyword="domain_id"	type="unsigned_integer"	set_rapidmark="gDomainID"	paramnum="0"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=31"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Domain ID, Range&lt;1-31&gt;"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain">
extern RLSTATUS 
rcc_config_obring_domain(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="domain_id"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
								<command_node	keyword="enable"	helpmethod="0"	help="Enable/no enable obring protocol"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_enable">
extern RLSTATUS 
rcc_config_obring_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_enable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="domain_id"	paramnum="0"	type="required" />
											</handler_param_order>

										</hd>

										<hd	type="kNoHandler"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_no_enable">
extern RLSTATUS 
rcc_config_obring_no_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_disable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="domain_id"	paramnum="0"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="fail-times"	helpmethod="0"	help="Change fail times"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="times"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr="L=3 U=60"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set times, range &lt;3-60&gt; seconds"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain_fail_times">
extern RLSTATUS 
rcc_config_obring_domain_fail_times(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_fail_times_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="domain_id"	paramnum="0"	type="required" />
												<ho	paramnam="times"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="hello-times"	helpmethod="0"	help="Change hello times"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="times"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr="L=1 U=10"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set times, range &lt;1-10&gt; seconds"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain_hello_times">
extern RLSTATUS 
rcc_config_obring_domain_hello_times(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_hello_times_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="domain_id"	paramnum="0"	type="required" />
												<ho	paramnam="times"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="primary-port"	helpmethod="0"	help="Enable/disable primary port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
									</parameter_list>

									<handler_list>
									</handler_list>

									<command_node_list>
										<command_node	keyword="disable"	helpmethod="0"	help="disable primary port function"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
											<parameter_list>
											</parameter_list>

											<handler_list>
												<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain_primary_port_disable">
extern RLSTATUS 
rcc_config_obring_domain_primary_port_disable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_primary_port_disable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}													<handler_param_order>
														<ho	paramnam="domain_id"	paramnum="0"	type="required" />
													</handler_param_order>

												</hd>

											</handler_list>

											<command_node_list>
											</command_node_list>

											<get_rapidmark_list>
											</get_rapidmark_list>

											<custflag_list>
											</custflag_list>

										</command_node>

										<command_node	keyword="enable"	helpmethod="0"	help="Enable primary port function"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
											<parameter_list>
												<pd	keyword="port"	type="unsigned_integer"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=63"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring port number"	helphandler="" />
											</parameter_list>

											<handler_list>
												<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain_primary_port_enable">
extern RLSTATUS 
rcc_config_obring_domain_primary_port_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_primary_port_enable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}													<handler_param_order>
														<ho	paramnam="domain_id"	paramnum="0"	type="required" />
														<ho	paramnam="port"	paramnum="1"	type="required" />
													</handler_param_order>

												</hd>

											</handler_list>

											<command_node_list>
											</command_node_list>

											<get_rapidmark_list>
											</get_rapidmark_list>

											<custflag_list>
											</custflag_list>

										</command_node>

									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="ring-port"	helpmethod="0"	help="Set ring port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="ring_port_1"	type="unsigned_integer"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=63"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring port number"	helphandler="" />
										<pd	keyword="ring_port_2"	type="unsigned_integer"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=63"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring port number"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_config_obring_domain_ring_port">
extern RLSTATUS 
rcc_config_obring_domain_ring_port(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_domain_ring_port_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="domain_id"	paramnum="0"	type="required" />
												<ho	paramnam="ring_port_1"	paramnum="1"	type="required" />
												<ho	paramnam="ring_port_2"	paramnum="2"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="mode"	helpmethod="0"	help="Ring mode"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="ring_mode"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=port-based|vlan-based|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring mode, Enum &lt;port-based, vlan-based&gt;"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_obring_mode">
extern RLSTATUS 
rcc_config_obring_mode(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_mode_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="ring_mode"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="new"	helpmethod="0"	help="Create OB-Ring domain"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="domain_name"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr="T=AL N=7"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="OB-Ring domain name, string length less than 8"	helphandler="" />
								<pd	keyword="domain_id"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr="L=1 U=31"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Domain id, Range &lt;1-31&gt;"	helphandler="" />
								<pd	keyword="node_prio"	type="enumerate"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=high|medium|low|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Node type, Enum &lt;high, medium, low&gt;"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_config_obring_new">
extern RLSTATUS 
rcc_config_obring_new(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_obring_new_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="domain_name"	paramnum="0"	type="required" />
										<ho	paramnam="domain_id"	paramnum="1"	type="required" />
										<ho	paramnam="node_prio"	paramnum="2"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="port"	helpmethod="0"	help="Enter specified port configuration mode"	helphandler=""	mode_support="true"	prompt_string="config-port-[[gPortNo]]"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="PortNo"	type="unsigned_integer"	set_rapidmark="gPortNo"	paramnum="0"	nokeyword="yes"	typename="unsigned integer"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Logic port number"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_port">
extern RLSTATUS 
rcc_config_port(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
	
	status = cli_config_port_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="PortNo"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
						<command_node	keyword="isolate"	helpmethod="0"	help="Port isolate protection"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="neigbor-probe"	helpmethod="0"	help="Enable/disable neigbor probe"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="port-security"	helpmethod="0"	help="Port security configuration for mac limit"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="kNoHandler"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="config_port_no_security">
extern RLSTATUS 
config_port_no_security(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_port_no_security_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="config_port_security">
extern RLSTATUS 
config_port_security(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_port_security_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
								<command_node	keyword="age-time"	helpmethod="0"	help="Age time for dynamic mac address in security port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="age-time"	type="unsigned_integer"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=60"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Age time (1~60 seconds)"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000002"	opt_param_mask="0x00000000"	func="rcc_config_port_security_age_time">
extern RLSTATUS 
rcc_config_port_security_age_time(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal = NULL;
    paramDescr  *pParamDescr;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;age-time&quot;, mConfigPortPort_securityAge_time_Age_time, &amp;pParamDescr );
    if ( OK != status )
    {
		return(status);
    } else pVal = (sbyte*)(pParamDescr-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}											<handler_param_order>
												<ho	paramnam="age-time"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="mac-address"	helpmethod="0"	help="Mac address"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="mac-address"	type="mac_address"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="mac address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mac address (format: xx:xx:xx:xx:xx:xx)"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000002"	opt_param_mask="0x00000000"	func="rcc_config_port_security_macaddr">
extern RLSTATUS 
rcc_config_port_security_macaddr(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
	
	status = cli_config_port_security_macaddr_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="mac-address"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

										<hd	type="kNoHandler"	req_param_mask="0x00000002"	opt_param_mask="0x00000000"	func="rcc_config_port_security_no_macaddr">
extern RLSTATUS 
rcc_config_port_security_no_macaddr(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal = NULL;
    paramDescr  *pParamDescr;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;mac-address&quot;, mConfigPortPort_securityMac_address_Mac_address, &amp;pParamDescr );
    if ( OK != status )
    {
		return(status);
    } else pVal = (sbyte*)(pParamDescr-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}											<handler_param_order>
												<ho	paramnam="mac-address"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

								<command_node	keyword="maximum"	helpmethod="0"	help="Maximum address limit per port"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
									<parameter_list>
										<pd	keyword="maximum"	type="unsigned_integer"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned integer"	validstr="L=1 U=132"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Maximum value (1-132)"	helphandler="" />
									</parameter_list>

									<handler_list>
										<hd	type="0"	req_param_mask="0x00000002"	opt_param_mask="0x00000000"	func="rcc_config_port_security_maximum">
extern RLSTATUS 
rcc_config_port_security_maximum(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
	
	status = cli_config_port_security_maximum_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}											<handler_param_order>
												<ho	paramnam="maximum"	paramnum="1"	type="required" />
											</handler_param_order>

										</hd>

									</handler_list>

									<command_node_list>
									</command_node_list>

									<get_rapidmark_list>
									</get_rapidmark_list>

									<custflag_list>
									</custflag_list>

								</command_node>

							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="pvid"	helpmethod="0"	help="Set port vlan id"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="speed-duplex"	helpmethod="0"	help="Set port speed and duplex mode"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="rate-limit"	helpmethod="0"	help="Rate limit configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="signal"	helpmethod="0"	help="Signal alarm configuration"	helphandler=""	mode_support="true"	prompt_string="config-signal"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_no_support_display">
extern RLSTATUS 
rcc_no_support_display(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
#else
    status = cli_no_support_display_handler(pCliEnv, pParams, pAuxBuf);

    return  status;
#endif

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
						<command_node	keyword="channum"	helpmethod="0"	help="Config channel number"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="channum"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr="L=1 U=16"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Channel number parameter (1-16)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_chan_num_config">
extern RLSTATUS 
rcc_chan_num_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_chan_num_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
										<ho	paramnam="channum"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="chanparam"	helpmethod="0"	help="Config channel parameter"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="chanid"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr="L=1 U=16"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Channel number parameter(1-16)"	helphandler="" />
								<pd	keyword="enable/disable"	type="enumerate"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=enable|disable|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Channel alarm enable/disable"	helphandler="" />
								<pd	keyword="alarmtype"	type="enumerate"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=CLOSE|OPEN|DOWN|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Config channel alarm type, support following type:(CLOSE, OPEN, DOWN)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_chan_param_config">
extern RLSTATUS 
rcc_chan_param_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_chan_param_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
										<ho	paramnam="chanid"	paramnum="0"	type="required" />
										<ho	paramnam="enable/disable"	paramnum="1"	type="required" />
										<ho	paramnam="alarmtype"	paramnum="2"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="enable"	helpmethod="0"	help="Enable(no enable) signal alarm feature "	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_signal_enable_config">
extern RLSTATUS 
rcc_signal_enable_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_signal_enable_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

								<hd	type="kNoHandler"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_signal_no_enable_config">
extern RLSTATUS 
rcc_signal_no_enable_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_signal_no_enable_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="jitter"	helpmethod="0"	help="Config signal jitter feature"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="enable/disable"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=enable|disable|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Remove jitter enable/disable "	helphandler="" />
								<pd	keyword="time"	type="unsigned_char"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned char"	validstr="L=1 U=200"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set jitter probe time (1-200ms)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_jitter_config">
extern RLSTATUS 
rcc_jitter_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_jitter_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
										<ho	paramnam="enable/disable"	paramnum="0"	type="required" />
										<ho	paramnam="time"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="sampcycle"	helpmethod="0"	help="Config sample cycle time"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="time"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr="L=1 U=100"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Sample cycle time parameter (1-100ms)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_samp_cycle_config">
extern RLSTATUS 
rcc_samp_cycle_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_samp_cycle_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
										<ho	paramnam="time"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="show"	helpmethod="0"	help="Display signal alarm startup configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_config_signal_show">
extern RLSTATUS 
rcc_config_signal_show(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_show_signal_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="workmode"	helpmethod="0"	help="Config signal alarm work mode"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="mode"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=udp|tcp|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set work mode parameter (udp/tcp)"	helphandler="" />
								<pd	keyword="ip"	type="ip_address"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set server ip addess"	helphandler="" />
								<pd	keyword="port"	type="unsigned_short"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="unsigned short"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Set server port number"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_work_mode_cofig">
extern RLSTATUS 
rcc_work_mode_cofig(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
#if MODULE_SIGNAL
    status = cli_work_mode_config_handler(pCliEnv, pParams, pAuxBuf);
#endif

    return status;
}									<handler_param_order>
										<ho	paramnam="mode"	paramnum="0"	type="required" />
										<ho	paramnam="ip"	paramnum="1"	type="required" />
										<ho	paramnam="port"	paramnum="2"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="traffic-statistic"	helpmethod="0"	help="Traffic statistic configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="port-list"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr="T=AL N=32"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Port list, separate by &apos;,&apos;. Example: 1,2,4,7"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_traffic_statistic">
extern RLSTATUS 
rcc_config_traffic_statistic(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_config_traffic_statistic_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="port-list"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="trap"	helpmethod="0"	help="Local trap configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="add"	helpmethod="0"	help="Add a trap type"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="trapType"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=5 D=| T=REBOOT|PORT|RING|VOL|TRAFFIC|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Trap type (REBOOT, PORT, RING, VOL, TRAFFIC)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_trap_add">
extern RLSTATUS 
rcc_config_trap_add(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_add_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="trapType"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="delete"	helpmethod="0"	help="Delete a trap type"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="trapType"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=5 D=| T=REBOOT|PORT|RING|VOL|TRAFFIC|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Trap type (REBOOT, PORT, RING, VOL, TRAFFIC)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_trap_delete">
extern RLSTATUS 
rcc_config_trap_delete(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_delete_handler(pCliEnv, pParams, pAuxBuf);
    
	return status;
}									<handler_param_order>
										<ho	paramnam="trapType"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="enable"	helpmethod="0"	help="Enable(no enable) local trap feature "	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_config_trap_enable">
extern RLSTATUS 
rcc_config_trap_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_enable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

								<hd	type="kNoHandler"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_config_trap_no_enable">
extern RLSTATUS 
rcc_config_trap_no_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_no_enable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="server-mac"	helpmethod="0"	help="Config trap server mac address"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="mac-addr"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Mac address"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_config_trap_server_mac">
extern RLSTATUS 
rcc_config_trap_server_mac(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_server_mac_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="mac-addr"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="show"	helpmethod="0"	help="Display local trap configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_config_trap_show">
extern RLSTATUS 
rcc_config_trap_show(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_config_trap_show_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="user"	helpmethod="0"	help="User configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="access"	helpmethod="0"	help="Change user access level"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="name"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Login"	helphandler="" />
								<pd	keyword="access"	type="string"	set_rapidmark=""	paramnum="1"	nokeyword="no"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Access level"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="RCC_EXEC_UserAccess">
extern RLSTATUS 
RCC_EXEC_UserAccess(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal1 = NULL;
    paramDescr  *pParamDescr1;
    sbyte       *pVal2 = NULL;
    paramDescr  *pParamDescr2;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;name&quot;, mConfigUserAccess_Name, &amp;pParamDescr1 );
    if ( OK != status )
    {
		return(status);
    } else pVal1 = (sbyte*)(pParamDescr1-&gt;pValue);

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;access&quot;, mConfigUserAccess_Access, &amp;pParamDescr2 );
    if ( OK != status )
    {
		return(status);
    } else pVal2 = (sbyte*)(pParamDescr2-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="name"	paramnum="0"	type="required" />
										<ho	paramnam="access"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="add"	helpmethod="0"	help="Add a user"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="name"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="User name"	helphandler="" />
								<pd	keyword="access"	type="string"	set_rapidmark=""	paramnum="1"	nokeyword="no"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Access level"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000002"	func="RCC_EXEC_UserAdd">
extern RLSTATUS 
RCC_EXEC_UserAdd(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal1 = NULL;
    paramDescr  *pParamDescr1;
    sbyte       *pVal2 = NULL;
    paramDescr  *pParamDescr2;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;name&quot;, mConfigUserAdd_Name, &amp;pParamDescr1 );
    if ( OK != status )
    {
		return(status);
    } else pVal1 = (sbyte*)(pParamDescr1-&gt;pValue);

    /* get optional parameter */
    if (OK == RCC_DB_RetrieveParam(pParams, &quot;access&quot;, mConfigUserAdd_Access, &amp;pParamDescr2 ))
    {
        pVal2 = (sbyte*)(pParamDescr2-&gt;pValue);
    }

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="name"	paramnum="0"	type="required" />
										<ho	paramnam="access"	paramnum="1"	type="optional" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="delete"	helpmethod="0"	help="Delete a user"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="name"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="User to delete"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="RCC_EXEC_UserDelete">
extern RLSTATUS 
RCC_EXEC_UserDelete(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal = NULL;
    paramDescr  *pParamDescr;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, &quot;name&quot;, mConfigUserDelete_Name, &amp;pParamDescr );
    if ( OK != status )
    {
		return(status);
    } else pVal = (sbyte*)(pParamDescr-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="name"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="password"	helpmethod="0"	help="Change user password"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword=""	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr=""	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="RCC_EXEC_UserPassword">
extern RLSTATUS 
RCC_EXEC_UserPassword(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    sbyte       *pVal = NULL;
    paramDescr  *pParamDescr;

    /* get required parameter */
    status = RCC_DB_RetrieveParam(pParams, NULL, mConfigUserPassword_NULL1, &amp;pParamDescr );
    if ( OK != status )
    {
		return(status);
    } else pVal = (sbyte*)(pParamDescr-&gt;pValue);

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
										<ho	paramnam="(unnamed1)"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="show"	helpmethod="0"	help="Show all users"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="RCC_EXEC_UserShow">
extern RLSTATUS 
RCC_EXEC_UserShow(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="debug"	helpmethod="0"	help="Enter debug command level"	helphandler=""	mode_support="true"	prompt_string="debug"	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
			</handler_list>

			<command_node_list>
				<command_node	keyword="diag"	helpmethod="0"	help="Diagnostics for board hardware"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="board_name"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=GE22103MA|GE2C400U|GE1040PU|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Diagnostic test for board, support following board:\r\n( GE22103MA, GE2C400U, GE1040PU )"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_debug_diag">
extern RLSTATUS 
rcc_debug_diag(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_diag_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="board_name"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="eeprom"	helpmethod="0"	help="Eeprom data operation"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="clear"	helpmethod="0"	help="Clear eeprom data"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="offset"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Hexadecimal offset-address of eeprom"	helphandler="" />
								<pd	keyword="nbytes"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Decimal clear size"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_debug_eeprom_clear">
extern RLSTATUS 
rcc_debug_eeprom_clear(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_eeprom_clear_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="offset"	paramnum="0"	type="required" />
										<ho	paramnam="nbytes"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="dump"	helpmethod="0"	help="Dump eeprom data"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="offset"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Hexadecimal offset-address of eeprom"	helphandler="" />
								<pd	keyword="nbytes"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Decimal dump size"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000002"	func="rcc_debug_eeprom_dump">
extern RLSTATUS 
rcc_debug_eeprom_dump(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_eeprom_dump_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="offset"	paramnum="0"	type="required" />
										<ho	paramnam="nbytes"	paramnum="1"	type="optional" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="format"	helpmethod="0"	help="Format eeprom"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_debug_eeprom_format">
extern RLSTATUS 
rcc_debug_eeprom_format(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_eeprom_format_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
								<cf	flag="kRCC_COMMAND_CUSTOM1" />
							</custflag_list>

						</command_node>

						<command_node	keyword="test"	helpmethod="0"	help="Test eeprom write"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="offset"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Hexadecimal offset-address of eeprom"	helphandler="" />
								<pd	keyword="nbytes"	type="unsigned_short"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned short"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Decimal size to write"	helphandler="" />
								<pd	keyword="value"	type="string"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="The value to write"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_debug_eeprom_test">
extern RLSTATUS 
rcc_debug_eeprom_test(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_eeprom_test_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="offset"	paramnum="0"	type="required" />
										<ho	paramnam="nbytes"	paramnum="1"	type="required" />
										<ho	paramnam="value"	paramnum="2"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="login"	helpmethod="0"	help="CLI Login enable/disable"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="enable|disable"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=enable|disable|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Enable: you must input password before enter CLI\r\nDisable: skip login and enter CLI directly "	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_debug_login">
extern RLSTATUS 
rcc_debug_login(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_login_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="enable|disable"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="module"	helpmethod="0"	help="Module debug control"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="add|del|show"	type="enumerate"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=add|del|show|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Debug module add/del/show\r\nadd: enable module debug\r\ndel: disable module debug\r\nshow: display debug-module"	helphandler="" />
						<pd	keyword="module"	type="enumerate"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="enumerate"	validstr="N=3 D=| T=nms|obring|uart|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Module name, support following module name:\r\n&lt;nms,obring,uart&gt;"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000002"	func="rcc_debug_module">
extern RLSTATUS 
rcc_debug_module(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_module_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="add|del|show"	paramnum="0"	type="required" />
								<ho	paramnam="module"	paramnum="1"	type="optional" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="obring"	helpmethod="0"	help="Batch all OB-Ring nodes"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="disable"	helpmethod="0"	help="Disable all nodes OB-Ring protocol"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="ring_index"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring index (0-15)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_debug_obring_disable">
extern RLSTATUS 
rcc_debug_obring_disable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_obring_disable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="ring_index"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="enable"	helpmethod="0"	help="Enable all nodes OB-Ring protocol"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="ring_index"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring index (0-15)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_debug_obring_enable">
extern RLSTATUS 
rcc_debug_obring_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_obring_enable_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="ring_index"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="reboot"	helpmethod="0"	help="Reboot all nodes "	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="ring_index"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Ring index (0-15)"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_debug_obring_reboot">
extern RLSTATUS 
rcc_debug_obring_reboot(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_obring_reboot_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="ring_index"	paramnum="0"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="switch"	helpmethod="0"	help="Switch register opertion"	helphandler=""	mode_support="true"	prompt_string="debug-switch"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="getreg"	helpmethod="0"	help="Get the register value"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="page"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Select page value"	helphandler="" />
								<pd	keyword="address"	type="string"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Address range, separated by character &apos;-&apos;,\r\nand max address is 0xFF, max address len is 8"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000003"	opt_param_mask="0x00000000"	func="rcc_debug_switch_getreg">
extern RLSTATUS 
rcc_debug_switch_getreg(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_switch_getreg_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="page"	paramnum="0"	type="required" />
										<ho	paramnam="address"	paramnum="1"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="setreg"	helpmethod="0"	help="Set the register value"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
								<pd	keyword="page"	type="string"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Select page value"	helphandler="" />
								<pd	keyword="address"	type="string"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Address range, separated by character &apos;-&apos;,\r\nand max address is 0xFF, max address len is 8"	helphandler="" />
								<pd	keyword="value"	type="string"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Value string, separated by character &apos;-&apos;"	helphandler="" />
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_debug_switch_setreg">
extern RLSTATUS 
rcc_debug_switch_setreg(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_debug_switch_setreg_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
										<ho	paramnam="page"	paramnum="0"	type="required" />
										<ho	paramnam="address"	paramnum="1"	type="required" />
										<ho	paramnam="value"	paramnum="2"	type="required" />
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="enable"	helpmethod="0"	help="Turn on privileged commands"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="true"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_enable">
extern RLSTATUS 
rcc_exec_enable(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
	status = cli_exec_enable_handler(pCliEnv, pParams, pAuxBuf);
    return status;
}					<handler_param_order>
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
				<cf	flag="kRCC_COMMAND_CUSTOM1" />
			</custflag_list>

		</command_node>

		<command_node	keyword="exit"	helpmethod="0"	help="Exit intermediate mode"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="true"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
				<pd	keyword="all"	type="absolute"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Exit to root"	helphandler="" />
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000001"	func="rcc_exec_exit">
extern RLSTATUS 
rcc_exec_exit(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
#if 1
    RLSTATUS status = OK;

    status = cli_exec_exit_handler(pCliEnv, pParams, pAuxBuf);

    return status;
#else
    sbyte       *pVal = NULL;
    paramDescr  *pParamDescr;

    /* get optional parameter */
    if (OK == RCC_DB_RetrieveParam((struct paramList*) pParams, &quot;all&quot;, mExit_All, &amp;pParamDescr ))
    {
        pVal = (sbyte*)(pParamDescr-&gt;pValue);
    }

    return (NULL == pVal ? STATUS_RCC_EXIT : STATUS_RCC_EXIT_ALL);
#endif
}					<handler_param_order>
						<ho	paramnam="all"	paramnum="0"	type="optional" />
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
				<cf	flag="kRCC_COMMAND_CUSTOM1" />
			</custflag_list>

		</command_node>

		<command_node	keyword="help"	helpmethod="0"	help="Show command help"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="true"	no_generate="false"	meta_node="true"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
				<pd	keyword="commands"	type="absolute"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="System help"	helphandler="" />
				<pd	keyword="edit"	type="absolute"	set_rapidmark=""	paramnum="1"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Show editing keys"	helphandler="" />
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="RCC_EXEC_Help">
extern RLSTATUS 
RCC_EXEC_Help(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    return RCC_HELP_RetrieveHelp(pCliEnv, NULL, FALSE);
}					<handler_param_order>
					</handler_param_order>

				</hd>

				<hd	type="0"	req_param_mask="0x00000002"	opt_param_mask="0x00000000"	func="RCC_EXEC_HelpEdit">
extern RLSTATUS 
RCC_EXEC_HelpEdit(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    return RCC_HELP_EditHelp(pCliEnv);
}					<handler_param_order>
						<ho	paramnam="edit"	paramnum="1"	type="required" />
					</handler_param_order>

				</hd>

				<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="RCC_EXEC_HelpGlobals">
extern RLSTATUS 
RCC_EXEC_HelpGlobals(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RCC_HELP_Globals(pCliEnv);
    return OK;
}					<handler_param_order>
						<ho	paramnam="commands"	paramnum="0"	type="required" />
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="history"	helpmethod="0"	help="Show command history"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="true"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_history">
extern RLSTATUS 
rcc_exec_history(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    return RCC_HIST_DispHistBuff(pCliEnv);
}					<handler_param_order>
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="ping"	helpmethod="0"	help="Verify network connectivity"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
				<pd	keyword="host ip"	type="ip_address"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Destinaton ip address"	helphandler="" />
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_exec_ping">
extern RLSTATUS 
rcc_exec_ping(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_exec_ping_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}					<handler_param_order>
						<ho	paramnam="host ip"	paramnum="0"	type="required" />
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
				<cf	flag="kRCC_COMMAND_CUSTOM1" />
			</custflag_list>

		</command_node>

		<command_node	keyword="reset"	helpmethod="0"	help="Restart the system"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_reset">
extern RLSTATUS 
rcc_exec_reset(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_exec_reset_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}					<handler_param_order>
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
				<cf	flag="kRCC_COMMAND_CUSTOM1" />
			</custflag_list>

		</command_node>

		<command_node	keyword="show"	helpmethod="0"	help="Show running system information"	helphandler=""	mode_support="true"	prompt_string="show"	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
			</parameter_list>

			<handler_list>
			</handler_list>

			<command_node_list>
				<command_node	keyword="alarm"	helpmethod="0"	help="Diaplay switch signal running configuration"	helphandler=""	mode_support="true"	prompt_string="show-alarm"	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="signal"	helpmethod="0"	help="Diaplay switch signal running configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_signal">
extern RLSTATUS 
rcc_show_signal(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

#if MODULE_SIGNALE
    status  = cli_show_signal_handler(pCliEnv, pParams, pAuxBuf);
#endif
    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="counters"	helpmethod="0"	help="Display port statistics information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="port"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Logic port number"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_show_counters">
extern RLSTATUS 
rcc_show_counters(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_counters_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="port"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="device"	helpmethod="0"	help="Display device node information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_device">
extern RLSTATUS 
rcc_show_device(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_device_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="mac-address-table"	helpmethod="0"	help="Display MAC address table"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_mac_addr_table">
extern RLSTATUS 
rcc_show_mac_addr_table(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
	status = cli_show_mac_addr_table_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="memory"	helpmethod="0"	help="Display the information of memory"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_memory">
extern RLSTATUS 
rcc_exec_show_memory(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_memory_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="obring"	helpmethod="0"	help="Display OB-Ring protocol information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="topo"	type="absolute"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Display the topology of OB-Ring device"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_obring">
extern RLSTATUS 
rcc_exec_show_obring(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_obring_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_exec_show_obring_topo">
extern RLSTATUS 
rcc_exec_show_obring_topo(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_obring_topo_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="topo"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="port-config"	helpmethod="0"	help="Display all switch ports configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_port_config">
extern RLSTATUS 
rcc_exec_show_port_config(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_port_config_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="port-neigbor"	helpmethod="0"	help="Display all switch ports neigbor info"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_port_neigbor">
extern RLSTATUS 
rcc_exec_show_port_neigbor(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_port_neigbor_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="port-status"	helpmethod="0"	help="Display all switch ports status"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_port_status">
extern RLSTATUS 
rcc_exec_show_port_status(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_port_status_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="port-traffic"	helpmethod="0"	help="Display all switch ports traffic info"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_port_traffic">
extern RLSTATUS 
rcc_exec_show_port_traffic(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_port_traffic_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="qos"	helpmethod="0"	help="Display QoS running configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
					</handler_list>

					<command_node_list>
						<command_node	keyword="map"	helpmethod="0"	help="Display QoS priority-queue running configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_priority_queue_map">
extern RLSTATUS 
rcc_show_priority_queue_map(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
    status  = cli_show_priority_queue_map_handler(pCliEnv, pParams, pAuxBuf);
    
   return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

						<command_node	keyword="set"	helpmethod="0"	help="Display QoS setting running configuration"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
							<parameter_list>
							</parameter_list>

							<handler_list>
								<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_qos_set">
extern RLSTATUS 
rcc_show_qos_set(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    /* TO DO: Add your handler code here */
    status = cli_show_qos_set(pCliEnv, pParams, pAuxBuf);

    return status;
}									<handler_param_order>
									</handler_param_order>

								</hd>

							</handler_list>

							<command_node_list>
							</command_node_list>

							<get_rapidmark_list>
							</get_rapidmark_list>

							<custflag_list>
							</custflag_list>

						</command_node>

					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="register"	helpmethod="0"	help="Display switch chip register data"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="page"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="The page(Decimal) of register"	helphandler="" />
						<pd	keyword="address"	type="unsigned_char"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="The address(Decimal) of register"	helphandler="" />
						<pd	keyword="lenth"	type="unsigned_char"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="unsigned char"	validstr="L=1 U=8"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="The byte lenth(Decimal) of register"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_exec_show_register">
extern RLSTATUS 
rcc_exec_show_register(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;
    
    status = cli_show_register_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}

							<handler_param_order>
								<ho	paramnam="page"	paramnum="0"	type="required" />
								<ho	paramnam="address"	paramnum="1"	type="required" />
								<ho	paramnam="lenth"	paramnum="2"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="system"	helpmethod="0"	help="Display the system information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_system">
extern RLSTATUS 
rcc_show_system(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_system_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="task"	helpmethod="0"	help="Display the active task information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="runtime"	type="absolute"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Show the task runing time"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_task">
extern RLSTATUS 
rcc_show_task(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_show_task_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

						<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_show_task_runtime">
extern RLSTATUS 
rcc_show_task_runtime(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_task_runtime_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
								<ho	paramnam="runtime"	paramnum="0"	type="required" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
					</custflag_list>

				</command_node>

				<command_node	keyword="uart"	helpmethod="0"	help="Display the uart server running stats"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
						<pd	keyword="port"	type="unsigned_char"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="unsigned char"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="Uart port (port=0,1)"	helphandler="" />
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000001"	func="rcc_show_uart">
extern RLSTATUS 
rcc_show_uart(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

#if MODULE_UART_SERVER
	status = cli_show_uart_handler(pCliEnv, pParams, pAuxBuf);
#endif
    return status;
}							<handler_param_order>
								<ho	paramnam="port"	paramnum="0"	type="optional" />
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="version"	helpmethod="0"	help="Display the version information"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_exec_show_version">
extern RLSTATUS 
rcc_exec_show_version(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_version_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

				<command_node	keyword="vlan"	helpmethod="0"	help="Display VTU table"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="true"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
					<parameter_list>
					</parameter_list>

					<handler_list>
						<hd	type="0"	req_param_mask="0x00000000"	opt_param_mask="0x00000000"	func="rcc_show_vlan">
extern RLSTATUS 
rcc_show_vlan(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

    status = cli_show_vlan_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}							<handler_param_order>
							</handler_param_order>

						</hd>

					</handler_list>

					<command_node_list>
					</command_node_list>

					<get_rapidmark_list>
					</get_rapidmark_list>

					<custflag_list>
						<cf	flag="kRCC_COMMAND_CUSTOM1" />
					</custflag_list>

				</command_node>

			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="tftp"	helpmethod="0"	help="Upgrade firmware by tftp protocal"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0 | ENABLE"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="false"	no_generate="false"	meta_node="false"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
				<pd	keyword="server-ip"	type="ip_address"	set_rapidmark=""	paramnum="0"	nokeyword="yes"	typename="IP address"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="TFTP Server IP address"	helphandler="" />
				<pd	keyword="get|put"	type="enumerate"	set_rapidmark=""	paramnum="1"	nokeyword="yes"	typename="enumerate"	validstr="N=2 D=| T=get|put|"	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="get: get file from remote host\r\nput: put file onto remote host"	helphandler="" />
				<pd	keyword="filename"	type="string"	set_rapidmark=""	paramnum="2"	nokeyword="yes"	typename="string"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="The remote filename"	helphandler="" />
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000007"	opt_param_mask="0x00000000"	func="rcc_exec_tftp">
extern RLSTATUS 
rcc_exec_tftp(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    RLSTATUS    status = OK;

	status = cli_exec_tftp_handler(pCliEnv, pParams, pAuxBuf);

    return status;
}					<handler_param_order>
						<ho	paramnam="server-ip"	paramnum="0"	type="required" />
						<ho	paramnam="get|put"	paramnum="1"	type="required" />
						<ho	paramnam="filename"	paramnum="2"	type="required" />
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
			</custflag_list>

		</command_node>

		<command_node	keyword="tree"	helpmethod="0"	help="Show command tree"	helphandler=""	mode_support="false"	prompt_string=""	access_level="0"	allow_no_form="false"	inherit_rapidmarks="false"	global_node="true"	no_generate="false"	meta_node="true"	queue_node="false"	nolink_node="false"	partition="">
			<parameter_list>
				<pd	keyword="-syntax"	type="absolute"	set_rapidmark=""	paramnum="0"	nokeyword="no"	typename="absolute"	validstr=""	accessstr=""	defaultstr=""	customvalid=""	convert2base="No"	helpmethod="0"	helpstr="show full command syntax in tree"	helphandler="" />
			</parameter_list>

			<handler_list>
				<hd	type="0"	req_param_mask="0x00000001"	opt_param_mask="0x00000000"	func="rcc_exec_tree">
extern RLSTATUS 
rcc_exec_tree(cli_env *pCliEnv, paramList *pParams, sbyte *pAuxBuf)
{
    cmdNode     *pNode = RCC_DB_GetCommandNode(pCliEnv);
    sbyte       *pVal  = NULL;
    paramDescr  *pParamDescr;
    ubyte4       flags = 0;

    /* get optional parameter */
    if (OK == RCC_DB_RetrieveParam(pParams, &quot;-syntax&quot;, mTree__syntax, &amp;pParamDescr ))
        flags = kTREE_FLAG_SYNTAX;

    if (NULL == pNode)
        pNode = MMISC_GetCurrRoot(pCliEnv);

    if (FLAG_SET(pNode, kRCC_COMMAND_META))
        pNode = RCC_DB_GetParentNode(pCliEnv, pNode);

    RCC_DB_ShowTree(pCliEnv, pNode, 0, 0, flags);

    return OK;
}					<handler_param_order>
						<ho	paramnam="-syntax"	paramnum="0"	type="required" />
					</handler_param_order>

				</hd>

			</handler_list>

			<command_node_list>
			</command_node_list>

			<get_rapidmark_list>
			</get_rapidmark_list>

			<custflag_list>
				<cf	flag="kRCC_COMMAND_CUSTOM1" />
			</custflag_list>

		</command_node>

	</command_node_list>

</rcc_project>
